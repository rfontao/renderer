#version 460

#include "common.glsl"

struct VkDrawIndexedIndirectCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

layout (std430, buffer_reference, buffer_reference_align = 8) buffer CommandBuffer {
    VkDrawIndexedIndirectCommand commands[];
};

layout (push_constant, scalar) uniform PushConsts {
    vec4 frustumPlanes[6];
    CommandBuffer commandBufferAddress;
    DrawDataBuffer drawDataBufferAddress;
    ModelMatricesBuffer modelMatricesBufferAddress;
    vec2 padding;
} pc;


layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

bool IsVisible(uint commandIndex) {
    mat4 modelMatrix = pc.modelMatricesBufferAddress.matrices[pc.drawDataBufferAddress.drawData[commandIndex].modelMatrixIndex];
    AABB aabb = pc.drawDataBufferAddress.drawData[commandIndex].aabb;

    vec3 center = (aabb.min + aabb.max) * 0.5f;
    vec3 halfSize = (aabb.max - aabb.min) * 0.5f;

    for (int i = 0; i < 6; ++i) {
        vec4 plane = pc.frustumPlanes[i];

        const float extent = halfSize.x * abs(plane.x) + halfSize.y * abs(plane.y) + halfSize.z * abs(plane.z);
        const float s = dot(vec3(plane), center) + plane.w;
        if (s < -extent) {
            // The AABB is fully outside the frustum
            return false;
        }
    }
    return true;
}

// NOTE(RF): The plan atm is to set instanceCount to 0 if the mesh is not visible
//           In the future we should compact the buffer
void main() {
    uint index = gl_GlobalInvocationID.x;
    if (!IsVisible(index)) {
        pc.commandBufferAddress.commands[index].instanceCount = 0;
    }
}